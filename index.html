<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manufacturing Risk Dashboard - ML Operations</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            transition: margin-top 0.3s;
        }

        .container.black-swan-active {
            margin-top: 100px;
        }

        header {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .badge {
            display: inline-block;
            padding: 5px 15px;
            background: #4CAF50;
            color: white;
            border-radius: 20px;
            font-size: 0.9em;
            margin-left: 10px;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border-left: 4px solid #667eea;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        /* Search Bar Styles */
        .search-container {
            background: white;
            padding: 20px 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .search-wrapper {
            position: relative;
            max-width: 600px;
        }

        .search-input {
            width: 100%;
            padding: 15px 50px 15px 20px;
            font-size: 1.1em;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.3s;
        }

        .search-input:focus {
            border-color: #667eea;
        }

        .search-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.5em;
            color: #999;
            pointer-events: none;
        }

        .search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #667eea;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        .search-suggestions.active {
            display: block;
        }

        .suggestion-item {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-item:hover {
            background: #f8f9fa;
        }

        .suggestion-item .serial {
            font-weight: bold;
            color: #333;
        }

        .suggestion-item .details {
            font-size: 0.9em;
            color: #666;
            margin-top: 3px;
        }

        .suggestion-item .risk-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
            margin-left: 10px;
        }

        .no-results {
            padding: 15px 20px;
            text-align: center;
            color: #999;
        }

        /* Tickets Button Styles */
        .tickets-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(102, 126, 234, 0.3);
            transition: all 0.3s;
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tickets-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
        }

        .ticket-badge {
            background: #FFD700;
            color: #333;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 0.85em;
            font-weight: bold;
            min-width: 24px;
            text-align: center;
        }

        .ticket-badge.has-tickets {
            animation: badgePulse 2s infinite;
        }

        @keyframes badgePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.3s;
        }

        button:hover {
            background: #5568d3;
        }

        button.secondary {
            background: #6c757d;
        }

        button.secondary:hover {
            background: #5a6268;
        }

        #loadData {
            background: #28a745;
        }

        #loadData:hover {
            background: #218838;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: #f8f9fa;
            color: #667eea;
            font-weight: 600;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .risk-high {
            color: #dc3545;
            font-weight: bold;
        }

        .risk-medium {
            color: #ffc107;
            font-weight: bold;
        }

        .risk-low {
            color: #28a745;
            font-weight: bold;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .chart-container {
            position: relative;
            height: 500px;
            width: 100%;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #dc3545;
        }

        .success {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #28a745;
        }

        footer {
            text-align: center;
            color: white;
            margin-top: 40px;
            padding: 20px;
        }

        .ai-badge {
            font-size: 0.8em;
            opacity: 0.9;
        }

        /* Alert Notification Styles */
        .alert-button {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #dc3545;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: blink 1.5s infinite;
            display: none;
        }

        /* Black Swan Critical Banner */
        .black-swan-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #8B0000 0%, #DC143C 100%);
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            z-index: 9999;
            border-bottom: 4px solid #FFD700;
            display: none;
            animation: urgentPulse 1s infinite;
        }

        .black-swan-banner .banner-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
        }

        .black-swan-banner .banner-message {
            flex: 1;
            min-width: 300px;
        }

        .black-swan-banner .banner-actions {
            display: flex;
            gap: 10px;
        }

        .black-swan-banner button {
            background: #FFD700;
            color: #8B0000;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s;
        }

        .black-swan-banner button:hover {
            background: #FFC700;
            transform: scale(1.05);
        }

        @keyframes urgentPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.85; }
        }

        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.4; }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .alert-button:hover {
            background: #c82333;
            transform: scale(1.05);
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 0;
            border-radius: 10px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            animation: slideDown 0.3s;
            display: flex;
            flex-direction: column;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            border-bottom: 2px solid #dc3545;
            padding: 20px 30px;
            margin: 0;
            background: white;
            border-radius: 10px 10px 0 0;
            flex-shrink: 0;
        }

        .modal-header h2 {
            color: #dc3545;
            margin: 0;
        }

        .modal-body-wrapper {
            overflow-y: auto;
            padding: 20px 30px;
            flex-grow: 1;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover,
        .close:focus {
            color: #000;
        }

        .failure-detail {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #dc3545;
        }

        .failure-detail h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .failure-detail p {
            margin: 8px 0;
            line-height: 1.6;
        }

        .failure-detail.processed {
            background: #e8f5e9;
            border-left-color: #28a745;
            opacity: 0.6;
        }

        .action-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .action-btn.primary {
            background: #007bff;
            color: white;
        }

        .action-btn.primary:hover {
            background: #0056b3;
            transform: scale(1.05);
        }

        .action-btn.success {
            background: #28a745;
            color: white;
        }

        .action-btn.success:hover {
            background: #218838;
        }

        .action-btn.warning {
            background: #ffc107;
            color: #333;
        }

        .action-btn.warning:hover {
            background: #e0a800;
        }

        .action-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .status-message {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .status-message.success {
            background: #d4edda;
            border-left-color: #28a745;
            color: #155724;
        }

        .risk-indicator {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 4px;
            font-weight: bold;
            margin: 5px 0;
        }

        .recommendations {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin-top: 15px;
        }

        .recommendations h3 {
            color: #856404;
            margin-bottom: 10px;
        }

        .recommendations ul {
            margin-left: 20px;
        }

        .recommendations li {
            margin: 5px 0;
            color: #856404;
        }

        /* Ticket Filter Buttons */
        .filter-btn {
            background: #f8f9fa;
            color: #666;
            border: 2px solid #e0e0e0;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .filter-btn:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .filter-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        /* Ticket Cards */
        .ticket-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #667eea;
            transition: all 0.3s;
        }

        .ticket-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateX(5px);
        }

        .ticket-card.resolved {
            opacity: 0.7;
            border-left-color: #28a745;
        }

        .ticket-card.critical {
            border-left-color: #dc3545;
            background: #fff5f5;
        }

        .ticket-card.high {
            border-left-color: #fd7e14;
            background: #fff9f5;
        }

        .ticket-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .ticket-id {
            font-weight: bold;
            color: #667eea;
            font-size: 1.1em;
        }

        .ticket-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .ticket-status.open {
            background: #ffc107;
            color: #333;
        }

        .ticket-status.resolved {
            background: #28a745;
            color: white;
        }

        .ticket-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 12px;
            font-size: 0.95em;
        }

        .ticket-description {
            color: #555;
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .ticket-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #999;
        }

        .empty-state-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <!-- Black Swan Critical Event Banner -->
    <div id="blackSwanBanner" class="black-swan-banner">
        <div class="banner-content">
            <div class="banner-message">
                üö®üö® CATASTROPHIC EVENT: <span id="blackSwanCount">0</span> CRITICAL SENSOR FAILURES DETECTED üö®üö®
            </div>
            <div class="banner-actions">
                <button onclick="showFailureModal(activeFailures)">VIEW ALL FAILURES</button>
                <button onclick="isolateAllCritical()">ISOLATE ALL</button>
                <button onclick="createMassIncident()">CREATE MASS INCIDENT</button>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Alert Button (hidden by default) -->
        <button id="alertButton" class="alert-button">
            üö® SENSOR FAILURE DETECTED
        </button>

        <!-- Failure Details Modal -->
        <div id="failureModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <span class="close">&times;</span>
                    <h2>‚ö†Ô∏è Sensor Failure Alert</h2>
                </div>
                <div class="modal-body-wrapper">
                    <div id="modalBody">
                        <!-- Failure details will be inserted here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Tickets Modal -->
        <div id="ticketsModal" class="modal">
            <div class="modal-content">
                <div class="modal-header" style="border-bottom-color: #667eea;">
                    <span class="close" onclick="closeTicketsModal()">&times;</span>
                    <h2 style="color: #667eea;">üé´ Maintenance Tickets</h2>
                </div>
                <div class="modal-body-wrapper">
                    <div style="padding: 0 0 15px 0; display: flex; gap: 10px; border-bottom: 1px solid #e0e0e0; margin-bottom: 20px;">
                        <button onclick="filterTickets('all')" id="filterAll" class="filter-btn active">All (<span id="countAll">0</span>)</button>
                        <button onclick="filterTickets('open')" id="filterOpen" class="filter-btn">Open (<span id="countOpen">0</span>)</button>
                        <button onclick="filterTickets('resolved')" id="filterResolved" class="filter-btn">Resolved (<span id="countResolved">0</span>)</button>
                    </div>
                    <div id="ticketsBody">
                        <!-- Tickets will be inserted here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Create Ticket Form Modal -->
        <div id="createTicketModal" class="modal">
            <div class="modal-content" style="max-width: 600px;">
                <div class="modal-header" style="border-bottom-color: #667eea;">
                    <span class="close" onclick="closeCreateTicketModal()">&times;</span>
                    <h2 style="color: #667eea;">üé´ Create Maintenance Ticket</h2>
                </div>
                <div class="modal-body-wrapper">
                    <form id="ticketForm" onsubmit="submitTicket(event)">
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Sensor ID:</label>
                            <input type="text" id="ticketSensorId" readonly style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; background: #f8f9fa; font-weight: bold;">
                        </div>
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Priority:</label>
                            <select id="ticketPriority" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px;">
                                <option value="critical">üî¥ Critical</option>
                                <option value="high">üü† High</option>
                                <option value="medium" selected>üü° Medium</option>
                                <option value="low">üü¢ Low</option>
                            </select>
                        </div>
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #333;">Issue Description:</label>
                            <textarea id="ticketDescription" rows="4" required placeholder="Describe the issue and required maintenance..." style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; font-family: inherit; resize: vertical;"></textarea>
                        </div>
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button type="button" onclick="closeCreateTicketModal()" style="background: #6c757d;">Cancel</button>
                            <button type="submit" style="background: #667eea;">Create Ticket</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <header>
            <h1>ü§ñ Intelligent Manufacturing Dashboard</h1>
            <p class="subtitle">
                ML-Powered Component Failure Risk Analysis
                <span class="badge">AWS Serverless</span>
                <span class="badge" style="background: #764ba2;">ML Predictions</span>
                <span class="badge" id="connectionStatus" style="background: #6c757d;">‚ö™ Offline Mode</span>
            </p>
        </header>

        <div id="statusMessage"></div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-value" id="totalRecords">-</div>
                <div class="stat-label">Total Records</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="passedRecords">-</div>
                <div class="stat-label">Validated</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="failedRecords">-</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="passRate">-</div>
                <div class="stat-label">Pass Rate</div>
            </div>
        </div>

        <!-- Search Bar -->
        <div class="search-container">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
                <h2 style="margin: 0; color: #333;">üîç Search Components</h2>
                <button id="ticketsButton" class="tickets-button" onclick="showTicketsModal()">
                    üé´ Tickets <span id="ticketBadge" class="ticket-badge">0</span>
                </button>
            </div>
            <div class="search-wrapper">
                <input 
                    type="text" 
                    id="sensorSearch" 
                    class="search-input" 
                    placeholder="Search by serial number (e.g., SN-100001)..." 
                    autocomplete="off"
                />
                <span class="search-icon">üîé</span>
                <div id="searchSuggestions" class="search-suggestions"></div>
            </div>
        </div>

        <div class="dashboard">
            <div class="card full-width">
                <h2>üìä Risk Distribution</h2>
                <div class="controls">
                    <button id="loadData">üîÑ Load Sample Data</button>
                    <button id="sortHighRisk">‚¨áÔ∏è Sort by Highest Risk</button>
                    <button id="sortLowRisk" class="secondary">‚¨ÜÔ∏è Sort by Lowest Risk</button>
                    <button id="filterHighRisk" class="secondary">üî¥ Filter High Risk Only (&gt;0.7)</button>
                    <button id="resetView" class="secondary">‚Ü∫ Reset View</button>
                </div>
                <div class="chart-container">
                    <canvas id="riskChart"></canvas>
                </div>
            </div>

            <div class="card full-width">
                <h2>‚ö†Ô∏è Top 10 Highest Risk Components</h2>
                <div id="topRiskTable">
                    <div class="loading">Click "Load Sample Data" to begin analysis...</div>
                </div>
            </div>
        </div>

        <footer>
            <p>üöÄ AWS Serverless ML Pipeline - Free Tier Optimized</p>
            <p class="ai-badge">Developed with Gemini & GitHub Copilot assistance</p>
        </footer>
    </div>

    <script>
        // Global variables
        let allRecords = [];
        let currentRecords = [];
        let riskChart = null;
        let activeFailures = []; // Track unprocessed failures
        let processedFailures = []; // Track processed failures
        let isolatedSensors = []; // Track isolated sensors
        let maintenanceTickets = []; // Store all maintenance tickets
        let ticketIdCounter = 1000; // Starting ticket ID

        // Initialize Chart.js
        const ctx = document.getElementById('riskChart').getContext('2d');

        // Helper function to determine risk level
        function getRiskLevel(score) {
            if (score >= 0.7) return 'risk-high';
            if (score >= 0.4) return 'risk-medium';
            return 'risk-low';
        }

        function getRiskLabel(score) {
            if (score >= 0.7) return 'HIGH';
            if (score >= 0.4) return 'MEDIUM';
            return 'LOW';
        }

        // Update statistics
        function updateStats(summary) {
            document.getElementById('totalRecords').textContent = summary.total_records;
            document.getElementById('passedRecords').textContent = summary.passed;
            document.getElementById('failedRecords').textContent = summary.failed;
            document.getElementById('passRate').textContent = summary.pass_rate + '%';
        }

        // Show status message
        function showMessage(message, type = 'success') {
            const messageDiv = document.getElementById('statusMessage');
            messageDiv.innerHTML = `<div class="${type}">${message}</div>`;
            setTimeout(() => {
                messageDiv.innerHTML = '';
            }, 5000);
        }

        // Create/update chart
        function updateChart(records, sortLabel = 'Risk Score') {
            const labels = records.slice(0, 50).map(r => r.serial_number);
            const riskScores = records.slice(0, 50).map(r => r.failure_risk_score);
            const temperatures = records.slice(0, 50).map(r => r.component_temp_C);
            const vibrations = records.slice(0, 50).map(r => r.vibration_level);

            if (riskChart) {
                riskChart.destroy();
            }

            // Create pattern for isolated sensors
            const createStripedPattern = (color) => {
                const canvas = document.createElement('canvas');
                canvas.width = 10;
                canvas.height = 10;
                const ctx = canvas.getContext('2d');
                
                // Base color
                ctx.fillStyle = color;
                ctx.fillRect(0, 0, 10, 10);
                
                // Diagonal stripes
                ctx.strokeStyle = 'rgba(108, 117, 125, 0.6)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(10, 10);
                ctx.moveTo(-2, 0);
                ctx.lineTo(0, 2);
                ctx.moveTo(8, 0);
                ctx.lineTo(10, 2);
                ctx.stroke();
                
                return ctx.createPattern(canvas, 'repeat');
            };

            riskChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Failure Risk Score (${sortLabel})`,
                        data: riskScores,
                        backgroundColor: labels.map((label, index) => {
                            const score = riskScores[index];
                            const baseColor = score >= 0.7 ? 'rgba(220, 53, 69, 0.7)' :
                                             score >= 0.4 ? 'rgba(255, 193, 7, 0.7)' :
                                             'rgba(40, 167, 69, 0.7)';
                            
                            // Return pattern if isolated, otherwise solid color
                            return isolatedSensors.includes(label) ? createStripedPattern(baseColor) : baseColor;
                        }),
                        borderColor: riskScores.map(score => 
                            score >= 0.7 ? 'rgba(220, 53, 69, 1)' :
                            score >= 0.4 ? 'rgba(255, 193, 7, 1)' :
                            'rgba(40, 167, 69, 1)'
                        ),
                        borderWidth: labels.map(label => isolatedSensors.includes(label) ? 3 : 2),
                        barPercentage: 0.9,
                        categoryPercentage: 1.0
                    },
                    {
                        label: 'Data Points',
                        type: 'scatter',
                        data: riskScores.map((score, index) => ({
                            x: index,
                            y: score
                        })),
                        backgroundColor: riskScores.map(score => 
                            score >= 0.7 ? 'rgba(220, 53, 69, 1)' :
                            score >= 0.4 ? 'rgba(255, 193, 7, 1)' :
                            'rgba(40, 167, 69, 1)'
                        ),
                        borderColor: 'white',
                        borderWidth: 2,
                        pointRadius: 5,
                        pointHoverRadius: 8,
                        pointStyle: 'circle',
                        showLine: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 10,
                            bottom: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                font: {
                                    size: 14
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const index = context[0].dataIndex;
                                    const label = labels[index];
                                    const isolated = isolatedSensors.includes(label) ? ' üîí ISOLATED' : '';
                                    return label + isolated;
                                },
                                afterLabel: function(context) {
                                    const index = context.dataIndex;
                                    const lines = [
                                        `Temp: ${temperatures[index]}¬∞C`,
                                        `Vibration: ${vibrations[index]}`,
                                        `Risk: ${getRiskLabel(riskScores[index])}`
                                    ];
                                    
                                    if (isolatedSensors.includes(labels[index])) {
                                        lines.push('Status: ISOLATED - Ticket Required');
                                    }
                                    
                                    return lines;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: Math.max(...riskScores) < 0.1 ? 0.1 : 1,
                            title: {
                                display: true,
                                text: 'Failure Risk Probability (0-1)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Components (Showing 50 of ' + records.length + ')',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                display: false,
                                maxRotation: 0,
                                minRotation: 0
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        // Update top risk table
        function updateTopRiskTable(records) {
            const topRisks = records.slice(0, 10);
            let html = `
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Serial Number</th>
                            <th>Temperature (¬∞C)</th>
                            <th>Vibration</th>
                            <th>Risk Score</th>
                            <th>Risk Level</th>
                            <th>Status</th>
                            <th>Timestamp</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            topRisks.forEach((record, index) => {
                const riskClass = getRiskLevel(record.failure_risk_score);
                const riskLabel = getRiskLabel(record.failure_risk_score);
                const isIsolated = isolatedSensors.includes(record.serial_number);
                const isProcessed = processedFailures.includes(record.serial_number);
                
                let statusBadge = '';
                if (isProcessed) {
                    statusBadge = '<span class="badge" style="background: #28a745;">‚úÖ PROCESSED</span>';
                } else if (isIsolated) {
                    statusBadge = '<span class="badge" style="background: #6c757d;">üîí ISOLATED</span>';
                } else if (record.validation_status === 'FAIL') {
                    statusBadge = '<span class="badge" style="background: #dc3545;">‚ùå FAIL</span>';
                } else {
                    statusBadge = '<span class="badge" style="background: #28a745;">‚úì PASS</span>';
                }
                
                html += `
                    <tr ${record.validation_status === 'FAIL' && !isProcessed ? 'style="background-color: #ffe6e6;"' : ''}>
                        <td><strong>${index + 1}</strong></td>
                        <td><strong>${record.serial_number}</strong>${isIsolated ? ' üîí' : ''}</td>
                        <td class="${record.component_temp_C > 120 ? 'risk-high' : ''}">${record.component_temp_C}¬∞C</td>
                        <td class="${record.vibration_level > 10 ? 'risk-high' : ''}">${record.vibration_level}</td>
                        <td class="${riskClass}">${record.failure_risk_score.toFixed(4)}</td>
                        <td class="${riskClass}">${riskLabel}</td>
                        <td>${statusBadge}</td>
                        <td>${record.timestamp}</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
            `;

            document.getElementById('topRiskTable').innerHTML = html;
        }

        // API Gateway URL
        const API_GATEWAY_URL = 'https://0wpit90c06.execute-api.us-west-2.amazonaws.com/prod/predict';

        // Load data from AWS Lambda via API Gateway
        async function loadSampleData() {
            showMessage('üîÑ Connecting to AWS Lambda API...', 'success');
            console.log('Starting API data load from:', API_GATEWAY_URL);

            try {
                // Test API connection first
                showMessage('üîå Testing API connection...', 'success');
                const testResponse = await fetch(API_GATEWAY_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sensor_id: 'CONNECTION-TEST',
                        temperature: 85.0,
                        vibration: 2.5,
                        pressure: 98.0,
                        speed: 1500
                    })
                });

                if (!testResponse.ok) {
                    throw new Error(`API returned status ${testResponse.status}`);
                }

                const testData = await testResponse.json();
                console.log('API Connection Test Response:', testData);
                
                // Update connection status badge
                const statusBadge = document.getElementById('connectionStatus');
                statusBadge.textContent = 'üü¢ Live - AWS Connected';
                statusBadge.style.background = '#28a745';
                statusBadge.style.animation = 'pulse 2s ease-in-out';
                
                showMessage('‚úÖ API Connection Verified! Loading sensor data...', 'success');

                // Generate 50 sensor readings and get ML predictions (reduced for faster loading)
                const now = new Date();
                let failedCount = 0;
                let successfulAPICalls = 0;
                
                // Determine if this is a "black swan" event (5% chance)
                const isBlackSwan = Math.random() < 0.05;
                
                // Create sensor data array with realistic risk distribution
                const sensorDataArray = [];
                
                for (let i = 0; i < 50; i++) {
                    let temp, vibration, pressure, speed;
                    
                    // Black Swan Event: 30-40% failing sensors (catastrophic scenario)
                    if (isBlackSwan) {
                        const rand = Math.random();
                        if (rand < 0.35) {
                            // 35% Critical (red) - Major failures
                            temp = 110 + Math.random() * 15;
                            vibration = 7 + Math.random() * 3;
                            pressure = 92 + Math.random() * 3;
                            speed = 1350 + Math.random() * 100;
                        } else if (rand < 0.55) {
                            // 20% High risk (orange) - Degrading
                            temp = 95 + Math.random() * 15;
                            vibration = 5 + Math.random() * 2;
                            pressure = 94 + Math.random() * 4;
                            speed = 1400 + Math.random() * 150;
                        } else if (rand < 0.75) {
                            // 20% Medium risk (yellow) - Concern
                            temp = 80 + Math.random() * 15;
                            vibration = 3.5 + Math.random() * 1.5;
                            pressure = 96 + Math.random() * 5;
                            speed = 1450 + Math.random() * 150;
                        } else {
                            // 25% Low risk (green) - Normal
                            temp = 65 + Math.random() * 15;
                            vibration = 1.5 + Math.random() * 2;
                            pressure = 97 + Math.random() * 5;
                            speed = 1500 + Math.random() * 150;
                        }
                    } else {
                        // Normal Operations: Healthy distribution with rare failures
                        const rand = Math.random();
                        if (rand < 0.02) {
                            // 2% Critical (red) - Very rare failures
                            temp = 110 + Math.random() * 15;
                            vibration = 7 + Math.random() * 3;
                            pressure = 92 + Math.random() * 3;
                            speed = 1350 + Math.random() * 100;
                        } else if (rand < 0.06) {
                            // 4% High risk (orange) - Uncommon degradation
                            temp = 95 + Math.random() * 15;
                            vibration = 5 + Math.random() * 2;
                            pressure = 94 + Math.random() * 4;
                            speed = 1400 + Math.random() * 150;
                        } else if (rand < 0.20) {
                            // 14% Medium risk (yellow) - Some monitoring needed
                            temp = 80 + Math.random() * 15;
                            vibration = 3.5 + Math.random() * 1.5;
                            pressure = 96 + Math.random() * 5;
                            speed = 1450 + Math.random() * 150;
                        } else {
                            // 80% Low risk (green) - Healthy majority
                            temp = 60 + Math.random() * 20;
                            vibration = 1.0 + Math.random() * 2.5;
                            pressure = 97 + Math.random() * 5;
                            speed = 1500 + Math.random() * 150;
                        }
                    }
                    
                    sensorDataArray.push({
                        sensor_id: `SN-${100000 + i}`,
                        temperature: parseFloat(temp.toFixed(1)),
                        vibration: parseFloat(vibration.toFixed(2)),
                        pressure: parseFloat(pressure.toFixed(1)),
                        speed: parseFloat(speed.toFixed(0)),
                        index: i
                    });
                }
                
                // Show black swan warning if applicable
                if (isBlackSwan) {
                    showMessage('‚ö†Ô∏è BLACK SWAN EVENT DETECTED: Multiple critical failures in progress!', 'error');
                    console.warn('üö® BLACK SWAN EVENT: Simulating catastrophic failure scenario');
                }
                
                showMessage(`‚è≥ Processing ${sensorDataArray.length} sensor predictions from AWS Lambda (batched for reliability)...`, 'success');
                
                // Process in batches of 10 to avoid overwhelming API Gateway
                const allResults = [];
                const batchSize = 10;
                
                for (let batchStart = 0; batchStart < sensorDataArray.length; batchStart += batchSize) {
                    const batch = sensorDataArray.slice(batchStart, batchStart + batchSize);
                    
                    const batchPromises = batch.map(sensorData => 
                        fetch(API_GATEWAY_URL, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(sensorData)
                        })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            // With Lambda Proxy Integration, response is direct JSON (not wrapped)
                            successfulAPICalls++;
                            const riskScore = data.risk_score;
                            const validationStatus = riskScore >= 0.7 ? 'FAIL' : 'PASS';
                            
                            if (validationStatus === 'FAIL') failedCount++;
                            
                            return {
                                timestamp: new Date(now.getTime() - sensorData.index * 600000).toISOString().slice(0, 19).replace('T', ' '),
                                serial_number: sensorData.sensor_id,
                                component_temp_C: sensorData.temperature,
                                vibration_level: sensorData.vibration,
                                failure_risk_score: riskScore,
                                validation_status: validationStatus
                            };
                        })
                        .catch(err => {
                            console.error(`API call failed for ${sensorData.sensor_id}:`, err);
                            throw err;
                        })
                    );
                    
                    const batchResults = await Promise.all(batchPromises);
                    allResults.push(...batchResults);
                    
                    console.log(`Processed batch ${Math.floor(batchStart / batchSize) + 1}/${Math.ceil(sensorDataArray.length / batchSize)} (${allResults.length}/${sensorDataArray.length} total)`);
                    
                    // Small delay between batches (100ms) to avoid rate limiting
                    if (batchStart + batchSize < sensorDataArray.length) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                console.log(`Successfully received ${successfulAPICalls} predictions from AWS Lambda`);
                
                // Sort by risk score (highest first)
                allResults.sort((a, b) => b.failure_risk_score - a.failure_risk_score);
                
                // Calculate distribution breakdown for logging
                const critical = allResults.filter(r => r.failure_risk_score >= 0.7).length;
                const high = allResults.filter(r => r.failure_risk_score >= 0.4 && r.failure_risk_score < 0.7).length;
                const medium = allResults.filter(r => r.failure_risk_score >= 0.2 && r.failure_risk_score < 0.4).length;
                const low = allResults.filter(r => r.failure_risk_score < 0.2).length;
                
                console.log(`üìä Risk Distribution: üî¥ Critical: ${critical} (${(critical/50*100).toFixed(1)}%) | üü† High: ${high} (${(high/50*100).toFixed(1)}%) | üü° Medium: ${medium} (${(medium/50*100).toFixed(1)}%) | üü¢ Low: ${low} (${(low/50*100).toFixed(1)}%)`);
                
                if (isBlackSwan) {
                    console.warn(`üö® BLACK SWAN EVENT ACTIVE - Catastrophic failure scenario simulated`);
                }
                
                const passRate = ((50 - failedCount) / 50 * 100).toFixed(1);
                
                const response = {
                    summary: {
                        total_records: 50,
                        passed: 50 - failedCount,
                        failed: failedCount,
                        pass_rate: parseFloat(passRate)
                    },
                    validated_records: allResults,
                    failed_records: allResults.filter(r => r.validation_status === 'FAIL'),
                    top_risk_components: allResults.slice(0, 10)
                };

                allRecords = response.validated_records;
                currentRecords = [...allRecords];

                updateStats(response.summary);
                updateChart(currentRecords, 'Highest Risk First (Default)');
                updateTopRiskTable(currentRecords);

                // Show alert if there are failures
                if (response.failed_records && response.failed_records.length > 0) {
                    // Check if this is a black swan event (>10 critical failures = >20%)
                    const isBlackSwanResult = response.failed_records.length > 10;
                    
                    if (isBlackSwanResult) {
                        // Enhanced alert for black swan events
                        showMessage(`üö® BLACK SWAN EVENT: ${response.failed_records.length} CRITICAL FAILURES DETECTED! Immediate action required!`, 'error');
                        console.error(`üö® CATASTROPHIC EVENT: ${response.failed_records.length} sensors in critical failure state`);
                    }
                    
                    showFailureAlert(response.failed_records);
                } else {
                    hideFailureAlert();
                }

                showMessage(`üöÄ SUCCESS! Loaded ${response.summary.total_records} records with REAL ML predictions from AWS Lambda (us-west-2)`, 'success');
                
            } catch (error) {
                console.error('API Error Details:', error);
                
                // Update connection status badge to offline
                const statusBadge = document.getElementById('connectionStatus');
                statusBadge.textContent = 'üî¥ Offline - Sample Data';
                statusBadge.style.background = '#dc3545';
                
                showMessage(`‚ùå API Connection Failed: ${error.message}. Using offline sample data.`, 'error');
                
                // Fallback to sample data
                const sampleResponse = generateSampleData();
                allRecords = sampleResponse.validated_records;
                currentRecords = [...allRecords];
                updateStats(sampleResponse.summary);
                updateChart(currentRecords, 'Highest Risk First (Default)');
                updateTopRiskTable(currentRecords);
                
                if (sampleResponse.failed_records && sampleResponse.failed_records.length > 0) {
                    showFailureAlert(sampleResponse.failed_records);
                }
            }
        }

        // Show failure alert
        function showFailureAlert(failedRecords) {
            activeFailures = failedRecords.filter(f => !processedFailures.includes(f.serial_number));
            
            const alertBtn = document.getElementById('alertButton');
            const isBlackSwan = failedRecords.length > 10; // >20% critical failure rate
            
            // Handle black swan banner
            if (isBlackSwan && activeFailures.length > 0) {
                showBlackSwanBanner(failedRecords.length);
            } else {
                hideBlackSwanBanner();
            }
            
            if (activeFailures.length === 0) {
                // All failures processed
                alertBtn.style.display = 'block';
                alertBtn.style.background = '#28a745';
                alertBtn.style.animation = 'none';
                alertBtn.textContent = `‚úÖ ALL FAILURES PROCESSED - SYSTEM STABLE`;
                alertBtn.onclick = () => showStatusSummary();
                hideBlackSwanBanner();
            } else {
                // Active failures remain
                alertBtn.style.display = 'block';
                
                if (isBlackSwan) {
                    // BLACK SWAN EVENT - Ultra severe styling
                    alertBtn.style.background = '#8B0000'; // Dark red
                    alertBtn.style.animation = 'blink 0.75s infinite'; // Faster blink
                    alertBtn.style.fontWeight = 'bold';
                    alertBtn.style.fontSize = '16px';
                    alertBtn.textContent = `üö®üö® BLACK SWAN: ${activeFailures.length} CRITICAL FAILURES - IMMEDIATE ACTION REQUIRED üö®üö®`;
                } else {
                    // Normal failure alert
                    alertBtn.style.background = '#dc3545';
                    alertBtn.style.animation = 'blink 1.5s infinite';
                    alertBtn.style.fontWeight = 'normal';
                    alertBtn.style.fontSize = '14px';
                    alertBtn.textContent = `üö® ${activeFailures.length} ACTIVE FAILURE${activeFailures.length > 1 ? 'S' : ''} - ${processedFailures.length} PROCESSED`;
                }
                
                alertBtn.onclick = () => showFailureModal(failedRecords);
            }
        }

        // Hide failure alert
        function hideFailureAlert() {
            document.getElementById('alertButton').style.display = 'none';
        }

        // Show black swan banner
        function showBlackSwanBanner(failureCount) {
            const banner = document.getElementById('blackSwanBanner');
            const countElement = document.getElementById('blackSwanCount');
            const container = document.querySelector('.container');
            
            countElement.textContent = failureCount;
            banner.style.display = 'block';
            container.classList.add('black-swan-active');
        }

        // Hide black swan banner
        function hideBlackSwanBanner() {
            const banner = document.getElementById('blackSwanBanner');
            const container = document.querySelector('.container');
            
            banner.style.display = 'none';
            container.classList.remove('black-swan-active');
        }

        // Isolate all critical sensors (black swan action)
        function isolateAllCritical() {
            if (!activeFailures || activeFailures.length === 0) return;
            
            activeFailures.forEach(failure => {
                if (!processedFailures.includes(failure.serial_number)) {
                    processedFailures.push(failure.serial_number);
                }
            });
            
            showMessage(`‚úÖ ALL ${activeFailures.length} CRITICAL SENSORS ISOLATED FROM PRODUCTION`, 'success');
            showFailureAlert([]); // Update UI to show all processed
            console.log(`üîí Isolated ${activeFailures.length} critical sensors from production line`);
        }

        // Create mass incident ticket (black swan action)
        function createMassIncident() {
            if (!activeFailures || activeFailures.length === 0) return;
            
            // Create individual tickets for each critical failure
            activeFailures.forEach(failure => {
                createTicketForSensor(failure.serial_number, 'critical', 'BLACK SWAN EVENT: Critical failure requiring immediate attention');
            });
            
            showMessage(`üé´ ${activeFailures.length} CRITICAL TICKETS CREATED for black swan event`, 'success');
            console.log(`üìã Created ${activeFailures.length} critical tickets for sensors: ${activeFailures.map(f => f.serial_number).join(', ')}`);
            updateTicketBadge();
        }

        // Tickets Modal Functions
        function showTicketsModal() {
            const modal = document.getElementById('ticketsModal');
            renderTickets('all');
            modal.style.display = 'block';
        }

        function closeTicketsModal() {
            document.getElementById('ticketsModal').style.display = 'none';
        }

        function filterTickets(filter) {
            // Update active filter button
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('filter' + filter.charAt(0).toUpperCase() + filter.slice(1)).classList.add('active');
            
            renderTickets(filter);
        }

        function renderTickets(filter) {
            const ticketsBody = document.getElementById('ticketsBody');
            let tickets = maintenanceTickets;
            
            // Apply filter
            if (filter === 'open') {
                tickets = tickets.filter(t => t.status === 'open');
            } else if (filter === 'resolved') {
                tickets = tickets.filter(t => t.status === 'resolved');
            }
            
            // Update counts
            document.getElementById('countAll').textContent = maintenanceTickets.length;
            document.getElementById('countOpen').textContent = maintenanceTickets.filter(t => t.status === 'open').length;
            document.getElementById('countResolved').textContent = maintenanceTickets.filter(t => t.status === 'resolved').length;
            
            if (tickets.length === 0) {
                ticketsBody.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìã</div>
                        <p><strong>No ${filter !== 'all' ? filter : ''} tickets found</strong></p>
                        <p style="color: #999; font-size: 0.9em;">Tickets will appear here when maintenance requests are created</p>
                    </div>
                `;
                return;
            }
            
            // Sort by timestamp (newest first)
            tickets.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            let html = tickets.map(ticket => {
                const priorityEmoji = {
                    'critical': 'üî¥',
                    'high': 'üü†',
                    'medium': 'üü°',
                    'low': 'üü¢'
                };
                
                return `
                    <div class="ticket-card ${ticket.status} ${ticket.priority}">
                        <div class="ticket-header">
                            <span class="ticket-id">${ticket.id}</span>
                            <span class="ticket-status ${ticket.status}">${ticket.status.toUpperCase()}</span>
                        </div>
                        <div class="ticket-info">
                            <div><strong>Sensor:</strong> ${ticket.sensor_id}</div>
                            <div><strong>Priority:</strong> ${priorityEmoji[ticket.priority]} ${ticket.priority.charAt(0).toUpperCase() + ticket.priority.slice(1)}</div>
                            <div><strong>Created:</strong> ${new Date(ticket.timestamp).toLocaleString()}</div>
                            <div><strong>Assigned To:</strong> ${ticket.assigned_to}</div>
                        </div>
                        <div class="ticket-description">
                            <strong>Issue:</strong><br>
                            ${ticket.description}
                        </div>
                        ${ticket.status === 'open' ? `
                            <div class="ticket-actions">
                                <button class="action-btn success" onclick="resolveTicket('${ticket.id}')">‚úÖ Resolve & Process</button>
                                <button class="action-btn primary" onclick="viewSensorDetails('${ticket.sensor_id}')">üìä View Sensor</button>
                            </div>
                        ` : `
                            <div style="color: #28a745; font-weight: 600; margin-top: 10px;">
                                ‚úÖ Resolved at ${new Date(ticket.resolved_at).toLocaleString()}
                            </div>
                        `}
                    </div>
                `;
            }).join('');
            
            ticketsBody.innerHTML = html;
        }

        function updateTicketBadge() {
            const badge = document.getElementById('ticketBadge');
            const openTickets = maintenanceTickets.filter(t => t.status === 'open').length;
            badge.textContent = openTickets;
            
            if (openTickets > 0) {
                badge.classList.add('has-tickets');
            } else {
                badge.classList.remove('has-tickets');
            }
        }

        // Create Ticket Functions
        function openCreateTicketModal(sensorId) {
            document.getElementById('ticketSensorId').value = sensorId;
            document.getElementById('ticketDescription').value = '';
            
            // Set priority based on sensor risk
            const sensor = allRecords.find(r => r.serial_number === sensorId);
            if (sensor) {
                const priority = sensor.failure_risk_score >= 0.7 ? 'critical' :
                                sensor.failure_risk_score >= 0.4 ? 'high' :
                                sensor.failure_risk_score >= 0.2 ? 'medium' : 'low';
                document.getElementById('ticketPriority').value = priority;
            }
            
            document.getElementById('createTicketModal').style.display = 'block';
        }

        function closeCreateTicketModal() {
            document.getElementById('createTicketModal').style.display = 'none';
        }

        function submitTicket(event) {
            event.preventDefault();
            
            const sensorId = document.getElementById('ticketSensorId').value;
            const priority = document.getElementById('ticketPriority').value;
            const description = document.getElementById('ticketDescription').value;
            
            createTicketForSensor(sensorId, priority, description);
            
            closeCreateTicketModal();
            showMessage(`‚úÖ Maintenance ticket created for ${sensorId}`, 'success');
        }

        function createTicketForSensor(sensorId, priority, description) {
            const ticket = {
                id: `TICKET-${ticketIdCounter++}`,
                sensor_id: sensorId,
                priority: priority,
                description: description,
                status: 'open',
                timestamp: new Date().toISOString(),
                assigned_to: 'Maintenance Team',
                resolved_at: null
            };
            
            maintenanceTickets.push(ticket);
            updateTicketBadge();
            console.log(`üé´ Created ticket ${ticket.id} for sensor ${sensorId}`);
        }

        function resolveTicket(ticketId) {
            const ticket = maintenanceTickets.find(t => t.id === ticketId);
            if (!ticket) return;
            
            ticket.status = 'resolved';
            ticket.resolved_at = new Date().toISOString();
            
            // Mark sensor as processed
            if (!processedFailures.includes(ticket.sensor_id)) {
                processedFailures.push(ticket.sensor_id);
            }
            
            // Remove from isolated sensors
            const isolatedIndex = isolatedSensors.indexOf(ticket.sensor_id);
            if (isolatedIndex > -1) {
                isolatedSensors.splice(isolatedIndex, 1);
            }
            
            // Update UI
            renderTickets(document.querySelector('.filter-btn.active').id.replace('filter', '').toLowerCase());
            updateTicketBadge();
            showMessage(`‚úÖ Ticket ${ticketId} resolved and sensor ${ticket.sensor_id} processed`, 'success');
            
            // Update failure alert
            const failedRecords = allRecords.filter(r => r.validation_status === 'FAIL');
            showFailureAlert(failedRecords);
            
            // Update chart to remove stripes
            updateChart(currentRecords, getCurrentSortMode());
        }

        function getCurrentSortMode() {
            // Determine current sort mode from UI or default
            return 'Highest Risk First (Default)';
        }

        function viewSensorDetails(sensorId) {
            // Highlight sensor in table and scroll to it
            const searchInput = document.getElementById('sensorSearch');
            searchInput.value = sensorId;
            searchInput.dispatchEvent(new Event('input'));
            closeTicketsModal();
            showMessage(`üìä Showing details for ${sensorId}`, 'success');
        }

        // Show status summary when all failures are processed
        function showStatusSummary() {
            const modal = document.getElementById('failureModal');
            const modalBody = document.getElementById('modalBody');
            
            let html = `
                <div class="status-message success">
                    <h3>‚úÖ System Status: All Clear</h3>
                    <p><strong>Total Failures Detected:</strong> ${processedFailures.length}</p>
                    <p><strong>All failures have been acknowledged and processed.</strong></p>
                    <p>Maintenance teams have been notified and corrective actions are in progress.</p>
                    <ul style="margin-top: 15px;">
                        <li>‚úì Critical components isolated from production</li>
                        <li>‚úì Maintenance tickets created and assigned</li>
                        <li>‚úì Quality control teams notified</li>
                        <li>‚úì System monitoring active for similar patterns</li>
                    </ul>
                    <p style="margin-top: 15px; font-weight: bold;">Continue monitoring the dashboard for new alerts.</p>
                </div>
            `;
            
            modalBody.innerHTML = html;
            modal.style.display = 'block';
        }

        // Process a specific failure
        function processFailure(serialNumber) {
            if (!processedFailures.includes(serialNumber)) {
                processedFailures.push(serialNumber);
            }
            
            // Mark the failure card as processed visually
            const failureCard = document.querySelector(`[data-sensor="${serialNumber}"]`);
            if (failureCard) {
                failureCard.classList.add('processed');
                const buttons = failureCard.querySelectorAll('.action-btn');
                buttons.forEach(btn => btn.disabled = true);
            }
            
            // Update alert button
            const failedRecords = allRecords.filter(r => r.validation_status === 'FAIL');
            showFailureAlert(failedRecords);
            
            // Show success message
            showMessage(`‚úÖ Sensor ${serialNumber} failure processed. Maintenance notified.`, 'success');
        }

        // Show failure modal with details
        function showFailureModal(failedRecords) {
            const modal = document.getElementById('failureModal');
            const modalBody = document.getElementById('modalBody');
            
            let html = '';
            
            failedRecords.forEach((record, index) => {
                const isProcessed = processedFailures.includes(record.serial_number);
                const tempExceed = record.component_temp_C > 120;
                const vibExceed = record.vibration_level > 10;
                
                let failureReason = [];
                if (tempExceed) failureReason.push(`Temperature: ${record.component_temp_C}¬∞C exceeds maximum tolerance (120¬∞C)`);
                if (vibExceed) failureReason.push(`Vibration: ${record.vibration_level} exceeds maximum tolerance (10.0)`);
                
                html += `
                    <div class="failure-detail ${isProcessed ? 'processed' : ''}" data-sensor="${record.serial_number}">
                        <h3>${isProcessed ? '‚úÖ' : 'üî¥'} Sensor #${index + 1}: ${record.serial_number} ${isProcessed ? '(PROCESSED)' : ''}</h3>
                        <p><strong>Timestamp:</strong> ${record.timestamp}</p>
                        <p><strong>Current Readings:</strong></p>
                        <ul>
                            <li>Temperature: <span class="risk-high">${record.component_temp_C}¬∞C</span> ${tempExceed ? '‚ö†Ô∏è CRITICAL' : ''}</li>
                            <li>Vibration: <span class="risk-high">${record.vibration_level}</span> ${vibExceed ? '‚ö†Ô∏è CRITICAL' : ''}</li>
                            <li>Risk Score: <span class="risk-indicator risk-high">${(record.failure_risk_score * 100).toFixed(1)}%</span></li>
                        </ul>
                        
                        <p><strong>Failure Reason:</strong></p>
                        <ul>
                            ${failureReason.map(reason => `<li>${reason}</li>`).join('')}
                        </ul>
                        
                        <div class="recommendations">
                            <h3>‚ö° Recommended Actions:</h3>
                            <ul>
                                <li><strong>IMMEDIATE:</strong> Isolate component ${record.serial_number} from production line</li>
                                <li><strong>PRIORITY:</strong> Inspect for mechanical damage or thermal stress</li>
                                <li><strong>INVESTIGATE:</strong> Review recent maintenance logs and operating conditions</li>
                                <li><strong>PREVENTIVE:</strong> Check adjacent components for similar warning signs</li>
                                <li><strong>REPORT:</strong> Notify maintenance team and quality control supervisor</li>
                            </ul>
                        </div>
                        
                        <p style="margin-top: 15px;"><strong>Potential Risks if Unaddressed:</strong></p>
                        <ul>
                            <li>üî• Complete component failure leading to production shutdown</li>
                            <li>‚öôÔ∏è Damage to downstream equipment or assembly line</li>
                            <li>üí∞ Costly emergency repairs and inventory losses</li>
                            <li>‚è±Ô∏è Extended downtime impacting delivery schedules</li>
                            <li>‚ö†Ô∏è Safety hazards for operators near overheating equipment</li>
                        </ul>
                        
                        <div class="action-buttons">
                            <button class="action-btn primary" onclick="isolateComponent('${record.serial_number}')" ${isProcessed ? 'disabled' : ''}>
                                üö´ Isolate Component
                            </button>
                            <button class="action-btn warning" onclick="openCreateTicketModal('${record.serial_number}')" ${isProcessed ? 'disabled' : ''}>
                                üîß Create Maintenance Ticket
                            </button>
                        </div>
                    </div>
                `;
            });
            
            modalBody.innerHTML = html;
            modal.style.display = 'block';
        }

        // Action button handlers
        function isolateComponent(serialNumber) {
            // Add to isolated sensors list
            if (!isolatedSensors.includes(serialNumber)) {
                isolatedSensors.push(serialNumber);
            }
            
            showMessage(`üö´ Component ${serialNumber} isolated from production line. Create a maintenance ticket to process this sensor.`, 'success');
            console.log(`üîí Isolated sensor ${serialNumber} from production`);
            
            // Update chart to show stripes
            updateChart(currentRecords, getCurrentSortMode());
            
            // Show prompt to create ticket
            setTimeout(() => {
                if (confirm(`Sensor ${serialNumber} is now isolated. Would you like to create a maintenance ticket?`)) {
                    openCreateTicketModal(serialNumber);
                }
            }, 500);
        }

        // Close modal
        document.querySelector('.close').onclick = function() {
            document.getElementById('failureModal').style.display = 'none';
        }

        window.onclick = function(event) {
            const modal = document.getElementById('failureModal');
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        }

        // Generate sample data for demonstration (OFFLINE FALLBACK ONLY)
        function generateSampleData() {
            const records = [];
            const now = new Date();
            let failedCount = 0;

            for (let i = 0; i < 50; i++) {
                let temp, vibration, validationStatus, riskScore;
                
                // Create 2-3 failing sensors with extreme values
                if (i === 5 || i === 12 || i === 23) {
                    // Critical failure conditions
                    temp = 115 + Math.random() * 10; // 115-125¬∞C (exceeds max tolerance)
                    vibration = 8 + Math.random() * 2; // 8-10 (exceeds max tolerance)
                    validationStatus = 'FAIL';
                    riskScore = 1.0;
                    failedCount++;
                } else {
                    // Normal operating conditions
                    temp = 60 + Math.random() * 50; // 60-110¬∞C
                    vibration = 0.5 + Math.random() * 4; // 0.5-4.5
                    validationStatus = 'PASS';
                    
                    // Simple risk calculation (mimics ML model)
                    riskScore = 0;
                    if (temp > 95) riskScore += (temp - 95) / 25;
                    if (vibration > 3.5) riskScore += (vibration - 3.5) / 2;
                    riskScore = Math.min(Math.max(riskScore, 0), 1);
                }

                records.push({
                    timestamp: new Date(now.getTime() - i * 600000).toISOString().slice(0, 19).replace('T', ' '),
                    serial_number: `SN-${100000 + i}`,
                    component_temp_C: parseFloat(temp.toFixed(1)),
                    vibration_level: parseFloat(vibration.toFixed(2)),
                    failure_risk_score: parseFloat(riskScore.toFixed(4)),
                    validation_status: validationStatus
                });
            }

            // Sort by risk score (highest first)
            records.sort((a, b) => b.failure_risk_score - a.failure_risk_score);

            const passRate = ((50 - failedCount) / 50 * 100).toFixed(1);

            return {
                summary: {
                    total_records: 50,
                    passed: 50 - failedCount,
                    failed: failedCount,
                    pass_rate: parseFloat(passRate)
                },
                validated_records: records,
                failed_records: records.filter(r => r.validation_status === 'FAIL'),
                top_risk_components: records.slice(0, 10)
            };
        }

        // Event listeners
        document.getElementById('loadData').addEventListener('click', loadSampleData);

        document.getElementById('sortHighRisk').addEventListener('click', () => {
            currentRecords.sort((a, b) => b.failure_risk_score - a.failure_risk_score);
            updateChart(currentRecords, 'Sorted: Highest Risk First');
            updateTopRiskTable(currentRecords);
            showMessage('üìä Sorted by highest risk first', 'success');
        });

        document.getElementById('sortLowRisk').addEventListener('click', () => {
            console.log('Sort Low Risk clicked');
            console.log('Before sort:', currentRecords.slice(0, 5).map(r => r.failure_risk_score));
            currentRecords.sort((a, b) => a.failure_risk_score - b.failure_risk_score);
            console.log('After sort:', currentRecords.slice(0, 5).map(r => r.failure_risk_score));
            updateChart(currentRecords, 'Sorted: Lowest Risk First');
            updateTopRiskTable(currentRecords);
            showMessage('üìä Sorted by lowest risk first - Showing safest components', 'success');
        });

        document.getElementById('filterHighRisk').addEventListener('click', () => {
            currentRecords = allRecords.filter(r => r.failure_risk_score >= 0.7);
            if (currentRecords.length === 0) {
                showMessage('‚ö†Ô∏è No high-risk components found', 'error');
                currentRecords = [...allRecords];
            } else {
                updateChart(currentRecords, 'Filtered: High Risk Only');
                updateTopRiskTable(currentRecords);
                showMessage(`üî¥ Filtered to ${currentRecords.length} high-risk components`, 'success');
            }
        });

        document.getElementById('resetView').addEventListener('click', () => {
            currentRecords = [...allRecords];
            updateChart(currentRecords, 'All Components');
            updateTopRiskTable(currentRecords);
            showMessage('‚Ü∫ View reset to all records', 'success');
        });

        // Search functionality
        const searchInput = document.getElementById('sensorSearch');
        const searchSuggestions = document.getElementById('searchSuggestions');

        searchInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.trim().toUpperCase();
            
            if (searchTerm.length === 0) {
                searchSuggestions.classList.remove('active');
                return;
            }

            // Filter records by serial number
            const matches = allRecords.filter(record => 
                record.serial_number.toUpperCase().includes(searchTerm)
            ).slice(0, 10); // Limit to 10 suggestions

            if (matches.length === 0) {
                searchSuggestions.innerHTML = '<div class="no-results">No sensors found matching "' + searchTerm + '"</div>';
                searchSuggestions.classList.add('active');
                return;
            }

            // Build suggestions HTML
            let html = '';
            matches.forEach(record => {
                const riskClass = getRiskLevel(record.failure_risk_score);
                const riskLabel = getRiskLabel(record.failure_risk_score);
                const statusIcon = record.validation_status === 'FAIL' ? '‚ùå' : '‚úì';
                
                html += `
                    <div class="suggestion-item" data-serial="${record.serial_number}">
                        <div class="serial">${statusIcon} ${record.serial_number} 
                            <span class="risk-badge ${riskClass}">${riskLabel}</span>
                        </div>
                        <div class="details">
                            Temp: ${record.component_temp_C}¬∞C | Vibration: ${record.vibration_level} | Risk: ${(record.failure_risk_score * 100).toFixed(1)}%
                        </div>
                    </div>
                `;
            });

            searchSuggestions.innerHTML = html;
            searchSuggestions.classList.add('active');

            // Add click handlers to suggestions
            document.querySelectorAll('.suggestion-item').forEach(item => {
                item.addEventListener('click', function() {
                    const serialNumber = this.getAttribute('data-serial');
                    selectSensor(serialNumber);
                });
            });
        });

        // Close suggestions when clicking outside
        document.addEventListener('click', function(e) {
            if (!searchInput.contains(e.target) && !searchSuggestions.contains(e.target)) {
                searchSuggestions.classList.remove('active');
            }
        });

        // Select and highlight a specific sensor
        function selectSensor(serialNumber) {
            searchInput.value = serialNumber;
            searchSuggestions.classList.remove('active');
            
            // Find the sensor in data
            const sensor = allRecords.find(r => r.serial_number === serialNumber);
            if (!sensor) return;
            
            // Filter to show just this sensor
            currentRecords = [sensor];
            updateChart(currentRecords, `Selected: ${serialNumber}`);
            updateTopRiskTable(currentRecords);
            
            // Show sensor details
            const riskLabel = getRiskLabel(sensor.failure_risk_score);
            const statusIcon = sensor.validation_status === 'FAIL' ? '‚ùå' : '‚úÖ';
            showMessage(
                `${statusIcon} ${serialNumber} - Risk: ${(sensor.failure_risk_score * 100).toFixed(1)}% (${riskLabel}) | ` +
                `Temp: ${sensor.component_temp_C}¬∞C | Vibration: ${sensor.vibration_level} | ` +
                `Status: ${sensor.validation_status}`, 
                sensor.validation_status === 'FAIL' ? 'error' : 'success'
            );
        }

        // Initial message
        showMessage('üëã Welcome! Click "Load Sample Data" to see ML predictions in action.', 'success');
    </script>
</body>
</html>
